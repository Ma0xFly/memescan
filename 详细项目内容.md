# MemeScan — 项目架构设计文档

> **团队共识文档** — 供两位开发者在黑客松 7 天周期内对齐目标和开发方向。
> 最后更新: 2026-02-17

---

## 一、项目愿景与设计目的

### 1.1 我们在做什么？

**MemeScan (The Rug-Pull Radar)** 是一个实时 Memecoin 安全扫描智能体。它的核心使命是：

> **在用户买入一个新代币之前，自动检测该代币是否是骗局（Rug Pull / 蜜罐）。**

具体来说，系统做三件事：

1. **监控** — 实时监听以太坊上 Uniswap V2 Factory 合约的 **PairCreated** 事件，发现新上线的代币
2. **仿真** — 通过 Anvil 分叉主网，在隔离环境中模拟"买入 → 卖出"交易，检测能否正常卖出、税率多高、Gas 是否异常
3. **分析** — 基于仿真结果生成结构化的安全审计报告，给出 0-100 的风险评分

### 1.2 为什么这样设计？

核心设计原则只有三条：

| 原则 | 含义 | 体现 |
|------|------|------|
| **安全第一** | 永远不向主网发送真实交易 | 所有交易仿真都在 Anvil 分叉上执行 |
| **模块化** | 每个服务独立、可测试、可替换 | Service-Repository 分层架构 |
| **Fail-Safe** | 系统崩溃时不丢关键数据 | 指数退避重连 + 优雅关闭 + 异步数据库持久化 |

---

## 二、系统架构总览

```mermaid
graph TB
    subgraph "接口层 (Interface)"
        APP["app.py<br/>Streamlit 仪表盘"]
    end

    subgraph "服务层 (Service)"
        MON["MonitorService<br/>事件监听器"]
        SIM["SimulationService<br/>Anvil 仿真引擎"]
        ANA["AnalysisService<br/>风险分析引擎"]
    end

    subgraph "领域层 (Domain)"
        MDL["models.py<br/>Token / SimulationResult / AuditReport"]
        DBM["db_models.py<br/>TokenRecord / SimulationRecord / AuditRecord"]
    end

    subgraph "基础设施层 (Infrastructure)"
        CFG["config.py<br/>配置单例"]
        DB["db.py<br/>异步数据库"]
        W3["web3_provider.py<br/>AsyncWeb3"]
        LOG["logging.py<br/>Loguru 日志"]
    end

    APP -->|"启动/停止"| MON
    APP -->|"手动扫描"| SIM
    APP -->|"手动扫描"| ANA
    MON -->|"新代币回调"| SIM
    SIM -->|"仿真结果"| ANA
    MON --> W3
    MON --> MDL
    SIM --> MDL
    ANA --> MDL
    DBM --> DB
    MON --> CFG
    SIM --> CFG
    ANA --> CFG
    APP --> LOG
```

### 数据流（从检测到报告）

```mermaid
sequenceDiagram
    participant Chain as 以太坊主网
    participant Mon as MonitorService
    participant Sim as SimulationService
    participant Anvil as Anvil 进程
    participant Ana as AnalysisService
    participant UI as Streamlit UI

    Mon->>Chain: eth_getLogs(PairCreated)
    Chain-->>Mon: 返回新交易对日志
    Mon->>Mon: 解码日志，提取代币地址
    Mon->>Sim: 回调 on_new_pair(Token)
    Sim->>Anvil: 启动 Anvil (fork 主网)
    Sim->>Anvil: cast call (买入仿真)
    Anvil-->>Sim: 返回 Gas / Revert
    Sim->>Anvil: cast call (卖出仿真)
    Anvil-->>Sim: 返回 Gas / Revert
    Sim->>Sim: 构建 SimulationResult
    Sim->>Anvil: 终止 Anvil 进程
    Sim-->>Ana: SimulationResult
    Ana->>Ana: 规则引擎评估 + 计算评分
    Ana-->>UI: AuditReport
    UI->>UI: 更新仪表盘
```

---

## 三、分层架构详解

### 3.1 基础设施层 — `core/`

这一层为整个应用提供**底层支撑**，不包含任何业务逻辑。

#### `core/config.py` — 配置中枢

| 要素 | 说明 |
|------|------|
| **核心类** | **AppSettings** (继承 BaseSettings) |
| **设计模式** | `@lru_cache` 单例 — 全局只实例化一次 |
| **数据来源** | `.env` 文件 → 环境变量 → 代码默认值（优先级从高到低） |
| **关键配置项** | RPC URL、Anvil 端口、轮询间隔、税率阈值、数据库路径、LLM 密钥 |

**被谁依赖**: 几乎所有模块 — 它是全局配置的唯一入口。

#### `core/db.py` — 异步数据库引擎

| 要素 | 说明 |
|------|------|
| **核心组件** | **Base** (声明式基类)、**async_engine**、**async_sessionmaker** |
| **关键函数** | `get_session()` — 异步上下文管理器，自动 commit / rollback / close |
| **初始化** | `init_db()` — 在应用启动时创建所有数据表 |
| **清理** | `shutdown_db()` — 释放连接池 |

**设计决策**: 使用 **aiosqlite** 而非 asyncpg。SQLite 零配置，适合黑客松 MVP；异步 SQLAlchemy 抽象层意味着后续切换 Postgres 只需改一行连接字符串。

#### `core/web3_provider.py` — Web3 连接

| 要素 | 说明 |
|------|------|
| **核心函数** | `get_async_web3()` — 返回缓存的 AsyncWeb3 实例 |
| **Provider** | AsyncHTTPProvider（非阻塞 JSON-RPC） |
| **健康检查** | `check_connection()` — 验证节点是否响应 |

**被谁依赖**: MonitorService（轮询事件）和 app.py（状态面板显示连接状态）。

#### `core/logging.py` — 日志系统

| 要素 | 说明 |
|------|------|
| **双通道输出** | stderr（彩色人类可读）+ 文件（JSON 结构化，按天轮转） |
| **初始化** | `setup_logging()` — 在 app.py 启动时调用一次 |

---

### 3.2 领域层 — `domain/`

这一层定义了**核心数据契约**，是所有服务之间传递数据的"语言"。

#### `domain/models.py` — Pydantic V2 领域模型

三个核心模型 + 一个枚举：

```
┌──────────────────────┐
│     RiskFlag (枚举)    │  HONEYPOT, HIGH_BUY_TAX, CANNOT_SELL, ...
└──────────────────────┘

┌──────────────────────┐
│     Token            │  address, symbol, pair_address, deployer, ...
│     (代币元数据)       │  所有地址字段通过 field_validator 自动小写化
└──────────────────────┘
           │
           ▼ 传入仿真
┌──────────────────────┐
│  SimulationResult    │  can_buy, can_sell, buy_tax_pct, sell_tax_pct,
│  (仿真输出)           │  buy_gas, sell_gas, is_honeypot, revert_reason
└──────────────────────┘
           │
           ▼ 传入分析
┌──────────────────────┐
│    AuditReport       │  token + simulation + risk_score + risk_flags
│    (审计报告)         │  + llm_summary + is_dangerous 属性
└──────────────────────┘
```

**关键设计**: 所有模型设置 `frozen=True`（不可变），避免在服务间传递时被意外修改。

#### `domain/db_models.py` — SQLAlchemy ORM 模型

| ORM 类 | 对应领域模型 | 数据表名 |
|--------|------------|---------|
| **TokenRecord** | Token | tokens |
| **SimulationRecord** | SimulationResult | simulations |
| **AuditRecord** | AuditReport | audits |

ORM 模型的字段与领域模型一一对应，但增加了自增主键 **id** 和数据库索引。

---

### 3.3 服务层 — `services/`

这一层是**核心业务逻辑**所在，三个服务各司其职。

#### `services/monitor.py` — 事件监听器

| 要素 | 说明 |
|------|------|
| **核心类** | **MonitorService** |
| **核心方法** | `start()` — 启动轮询循环（阻塞式）<br/>`stop()` — 发出关闭信号 |
| **工作方式** | 每 N 秒调用 `eth_getLogs` 查询新的 PairCreated 事件 |
| **过滤逻辑** | 只处理包含 WETH 的交易对（忽略 Token/Token 对） |
| **容错机制** | 指数退避重连：失败后等待 1s → 2s → 4s → ... → 最大 60s |
| **关闭方式** | 通过 `asyncio.Event` 实现优雅关闭，不会丢弃正在处理的事件 |
| **输出** | 通过回调 `on_new_pair(Token)` 将新代币分发给下游 |

**协作关系**: MonitorService 发现新代币 → 调用回调 → 触发 SimulationService。

#### `services/simulator.py` — Anvil 仿真引擎

| 要素 | 说明 |
|------|------|
| **核心类** | **SimulationService** |
| **设计模式** | **异步上下文管理器** (`async with SimulationService() as sim`) |
| **生命周期** | `fork_mainnet()` 启动 Anvil → 执行仿真 → `kill_anvil()` 终止 |
| **仿真流程** | 1. `cast call` 仿真买入 (swapExactETHForTokens)<br/>2. `cast call` 仿真卖出 (swapExactTokensForETH) |
| **蜜罐判定** | `can_buy=True` 且 `can_sell=False` → 蜜罐 |
| **异常处理** | 子进程超时 → 强制 kill；cast 失败 → 解析 stderr 中的 Revert 原因 |

**关键实现细节**:
- Anvil 以 `--no-mining` 模式启动，保证仿真结果的确定性
- 使用 Anvil 预充值账户 `0xf39F...` 作为仿真发送者
- 每次仿真都会新建一个 Anvil 分叉实例（上下文管理器保证清理）

#### `services/analyzer.py` — 风险分析引擎

| 要素 | 说明 |
|------|------|
| **核心类** | **AnalysisService** |
| **核心方法** | `analyze(Token, SimulationResult) → AuditReport` |
| **规则引擎** | `_evaluate_rules()` — 根据仿真结果生成风险标签列表 |
| **评分系统** | `_compute_score()` — 加权求和（蜜罐 40 分，高税 15 分，...） |
| **LLM 集成** | `_generate_summary()` — 当前为规则生成的文字摘要，预留了 RAG 接口 |

**评分权重表**:

| 风险标签 | 分值 |
|---------|------|
| HONEYPOT / CANNOT_SELL | 40 |
| HIDDEN_MINT | 25 |
| HIGH_BUY_TAX / HIGH_SELL_TAX | 15 |
| OWNERSHIP_NOT_RENOUNCED / PROXY_CONTRACT / BLACKLIST_FUNCTION / TRANSFER_PAUSABLE | 10 |
| ANTI_WHALE_LIMIT | 5 |
| 无法完成买入（附加分） | +30 |

---

### 3.4 接口层 — `app.py`

| 要素 | 说明 |
|------|------|
| **框架** | Streamlit |
| **状态管理** | `st.session_state` 存储报告列表、监控状态、事件日志 |
| **异步方案** | 后台守护线程运行独立的 `asyncio` 事件循环 |
| **侧边栏** | RPC 连接状态、启动/停止监控、手动扫描输入 |
| **主面板** | 指标概览（总扫描数、蜜罐数、高风险数）+ 可展开的审计报告卡片 + 事件日志 |

**线程模型**:
```
主线程 (Streamlit UI 渲染)
│
└─ 守护线程 (asyncio event loop)
   ├─ MonitorService.start()    — 持续轮询
   ├─ SimulationService         — 按需启动 Anvil
   └─ AnalysisService           — 按需分析
```

---

## 四、文件依赖关系全景图

```mermaid
graph LR
    subgraph "app.py"
        A[app.py]
    end

    subgraph "services/"
        B[monitor.py]
        C[simulator.py]
        D[analyzer.py]
    end

    subgraph "domain/"
        E[models.py]
        F[db_models.py]
    end

    subgraph "core/"
        G[config.py]
        H[db.py]
        I[web3_provider.py]
        J[logging.py]
    end

    A --> B & C & D & E & G & H & I & J
    B --> E & G & I
    C --> E & G
    D --> E & G
    F --> H
    H --> G
    I --> G
    J --> G
```

---

## 五、分工建议

> **前端 / UI 全部交给 AI 生成**（Streamlit 的布局、样式、组件代码），两位开发者聚焦核心技术。
> 分工按「**链上交互 & 仿真**」vs「**安全分析 & 数据工程**」拆分。

---

### 开发者 A — 链上交互 & 仿真引擎

**核心职责**: 确保系统能稳定地与以太坊主网交互、正确地 Fork 仿真。

| 优先级 | 模块 | 具体任务 | 验收标准 |
|--------|------|---------|---------|
| P0 | `services/monitor.py` | 接入真实 RPC (Alchemy/Infura)，验证 PairCreated 事件解码正确性 | 能在终端打印出实时新建的 WETH 交易对地址 |
| P0 | `services/simulator.py` | 完善 `simulate_buy_sell()` — 增加 approve 步骤、用 `cast send` 替代 `cast call` 使交易真正上链到 Anvil | 对已知蜜罐地址返回 `is_honeypot=True` |
| P0 | `services/simulator.py` | 实现**税率精确计算** — 买入前后比对 ETH/代币余额差值计算实际税率 | 对已知高税代币，`buy_tax_pct` / `sell_tax_pct` 偏差 < 2% |
| P1 | `core/web3_provider.py` | 增加 WebSocket Provider 选项 (`AsyncWebSocketProvider`)，降低事件延迟 | 可通过 `.env` 配置切换 HTTP/WS 模式 |
| P1 | `core/config.py` | 增加多链配置支持（BSC / Base），每条链独立的 RPC URL + Factory 地址 | 修改 `.env` 即可切换目标链 |
| P2 | `services/monitor.py` | 实现并发仿真 — 用 `asyncio.Semaphore` 控制同时运行的 Anvil 实例数 | 高峰期（同时 5+ 新代币）不会 OOM |

**需要掌握的技术点**:
- Foundry CLI (`anvil` / `cast`) 的参数和输出格式
- Uniswap V2 Router 的 ABI（**swapExactETHForTokens** / **swapExactTokensForETH**）
- ERC-20 的 **approve** 机制
- `asyncio.create_subprocess_exec` 的进程管理

---

### 开发者 B — 安全分析 & 数据工程

**核心职责**: 让分析引擎更智能、数据可持久化和查询。

| 优先级 | 模块 | 具体任务 | 验收标准 |
|--------|------|---------|---------|
| P0 | `services/analyzer.py` | 完善规则引擎 — 增加 **ownership 检查**（调用 `owner()` 判断是否 renounce）、**隐藏 mint 检测**（解析合约 bytecode 中的 mint 签名） | 对已知的 renounce/未 renounce 合约能正确标记 |
| P0 | `domain/models.py` | 根据仿真实际输出调整字段 — 增加 `liquidity_eth` (流动性)、`holder_count` 等链上数据字段 | 模型字段覆盖所有已采集数据源 |
| P0 | `domain/db_models.py` + `core/db.py` | 实现数据持久化 — 编写 Repository 层，将 Token / SimulationResult / AuditReport 写入 SQLite | 扫描结果重启后不丢失，可按地址查询历史 |
| P1 | `services/analyzer.py` | **LLM 集成** — 通过 Etherscan API 拉取已验证源码，构建 Prompt 让 LLM 分析可疑函数（如 `_transfer` 中的隐藏逻辑） | 对有已验证源码的合约返回 LLM 分析摘要 |
| P1 | 新文件 `services/etherscan.py` | 封装 Etherscan API 调用 — `get_contract_source(address)`、`get_creator(address)`、`is_verified(address)` | 可获取合约源码和部署者信息 |
| P2 | 新文件 `services/token_info.py` | 链上代币元数据采集 — 调用 `name()`, `symbol()`, `decimals()`, `totalSupply()`, `owner()` 填充 Token 模型 | 扫描出的代币有完整的名称、符号等信息 |

**需要掌握的技术点**:
- Etherscan API (合约源码、ABI、交易历史)
- ERC-20 标准接口 + 常见 Rug Pull 合约模式（隐藏 mint、黑名单、暂停转账）
- SQLAlchemy 2.0 异步 CRUD
- OpenAI API / Prompt Engineering

---

### 共同负责

| 模块 | 任务 | 说明 |
|------|------|------|
| `.env` + `config.py` | 统一环境配置 | 两人共享同一份 `.env.example`，确保参数命名一致 |
| `domain/models.py` | 数据模型变更 | 任何字段增删都需要同步通知对方，因为模型是两人代码的接口契约 |
| 集成测试 | 端到端验证 | 开发者 A 的仿真输出 → 开发者 B 的分析引擎 → 最终报告，联调时一起测 |
| `app.py` | UI 功能需求 | 需要什么 UI 功能告诉 AI 生成，两人 review 即可 |

---

### 7 天 Sprint 排期建议

```
Day 1-2 ──────────────────────────────────
  A: 接入真实 RPC，验证 MonitorService 能捕获事件
  B: 完善数据模型，实现数据库 Repository CRUD
  共同: 确定 .env 配置、约定 models.py 字段

Day 3-4 ──────────────────────────────────
  A: 完善 SimulationService（approve + 税率计算 + 真实蜜罐测试）
  B: 完善规则引擎（ownership 检查 + 隐藏 mint 检测）
  B: 封装 Etherscan API 服务

Day 5 ────────────────────────────────────
  联调: A 的仿真结果 → B 的分析引擎，端到端跑通
  AI: 生成 Streamlit UI

Day 6 ────────────────────────────────────
  A: 性能优化（并发仿真、WebSocket）
  B: LLM 集成（合约源码分析）
  共同: 修 Bug、补数据

Day 7 ────────────────────────────────────
  共同: 最终联调、Demo 准备、文档收尾
```

---

## 六、关键设计模式速查

| 模式 | 位置 | 作用 |
|------|------|------|
| **@lru_cache 单例** | config.py, web3_provider.py | 全局唯一实例，无需 DI 框架 |
| **异步上下文管理器** | SimulationService, get_session() | 确保资源（Anvil 进程、数据库会话）必定被清理 |
| **指数退避** | MonitorService._handle_error() | 应对 RPC 限速和网络波动 |
| **回调分发** | MonitorService → on_new_pair | 解耦事件监听和业务处理 |
| **不可变数据模型** | models.py (frozen=True) | 防止服务间传递数据时被意外修改 |
| **后台线程 + 事件循环** | app.py | 解决 Streamlit 同步框架与 asyncio 异步服务的兼容问题 |

---

## 七、启动方式

```bash
# 1. 安装依赖
pip install -r requirements.txt

# 2. 配置环境变量
cp .env.example .env
# 编辑 .env 填入 RPC URL

# 3. 确认 Foundry 已安装
anvil --version && cast --version

# 4. 启动应用
streamlit run app.py
```

---

## 八、后续扩展方向

- [ ] **WebSocket 监听**: 将 HTTP 轮询升级为 WebSocket 订阅，降低延迟
- [ ] **税率精确计算**: 在仿真中比较买入前后的代币余额差，精确计算滑点和税率
- [ ] **合约源码分析**: 通过 Etherscan API 拉取已验证源码，用 LLM 分析可疑函数
- [ ] **多链支持**: 扩展到 BSC / Base / Arbitrum（只需更换 RPC 和工厂合约地址）
- [ ] **Telegram Bot**: 将审计报告通过 Telegram 推送告警
- [ ] **Docker 部署**: 容器化整个应用栈
