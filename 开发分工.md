## 五、分工建议

> **前端 / UI 全部交给 AI 生成**（Streamlit 的布局、样式、组件代码），两位开发者聚焦核心技术。
> 分工按「**链上交互 & 仿真**」vs「**安全分析 & 数据工程**」拆分。

---

### 开发者 A — 链上交互 & 仿真引擎

**核心职责**: 确保系统能稳定地与以太坊主网交互、正确地 Fork 仿真。

| 优先级 | 模块 | 具体任务 | 验收标准 |
|--------|------|---------|---------|
| P0 | `services/monitor.py` | 接入真实 RPC (Alchemy/Infura)，验证 PairCreated 事件解码正确性 | 能在终端打印出实时新建的 WETH 交易对地址 |
| P0 | `services/simulator.py` | 完善 `simulate_buy_sell()` — 增加 approve 步骤、用 `cast send` 替代 `cast call` 使交易真正上链到 Anvil | 对已知蜜罐地址返回 `is_honeypot=True` |
| P0 | `services/simulator.py` | 实现**税率精确计算** — 买入前后比对 ETH/代币余额差值计算实际税率 | 对已知高税代币，`buy_tax_pct` / `sell_tax_pct` 偏差 < 2% |
| P1 | `core/web3_provider.py` | 增加 WebSocket Provider 选项 (`AsyncWebSocketProvider`)，降低事件延迟 | 可通过 `.env` 配置切换 HTTP/WS 模式 |
| P1 | `core/config.py` | 增加多链配置支持（BSC / Base），每条链独立的 RPC URL + Factory 地址 | 修改 `.env` 即可切换目标链 |
| P2 | `services/monitor.py` | 实现并发仿真 — 用 `asyncio.Semaphore` 控制同时运行的 Anvil 实例数 | 高峰期（同时 5+ 新代币）不会 OOM |

**需要掌握的技术点**:
- Foundry CLI (`anvil` / `cast`) 的参数和输出格式
- Uniswap V2 Router 的 ABI（**swapExactETHForTokens** / **swapExactTokensForETH**）
- ERC-20 的 **approve** 机制
- `asyncio.create_subprocess_exec` 的进程管理

---

### 开发者 B — 安全分析 & 数据工程

**核心职责**: 让分析引擎更智能、数据可持久化和查询。

| 优先级 | 模块 | 具体任务 | 验收标准 |
|--------|------|---------|---------|
| P0 | `services/analyzer.py` | 完善规则引擎 — 增加 **ownership 检查**（调用 `owner()` 判断是否 renounce）、**隐藏 mint 检测**（解析合约 bytecode 中的 mint 签名） | 对已知的 renounce/未 renounce 合约能正确标记 |
| P0 | `domain/models.py` | 根据仿真实际输出调整字段 — 增加 `liquidity_eth` (流动性)、`holder_count` 等链上数据字段 | 模型字段覆盖所有已采集数据源 |
| P0 | `domain/db_models.py` + `core/db.py` | 实现数据持久化 — 编写 Repository 层，将 Token / SimulationResult / AuditReport 写入 SQLite | 扫描结果重启后不丢失，可按地址查询历史 |
| P1 | `services/analyzer.py` | **LLM 集成** — 通过 Etherscan API 拉取已验证源码，构建 Prompt 让 LLM 分析可疑函数（如 `_transfer` 中的隐藏逻辑） | 对有已验证源码的合约返回 LLM 分析摘要 |
| P1 | 新文件 `services/etherscan.py` | 封装 Etherscan API 调用 — `get_contract_source(address)`、`get_creator(address)`、`is_verified(address)` | 可获取合约源码和部署者信息 |
| P2 | 新文件 `services/token_info.py` | 链上代币元数据采集 — 调用 `name()`, `symbol()`, `decimals()`, `totalSupply()`, `owner()` 填充 Token 模型 | 扫描出的代币有完整的名称、符号等信息 |

**需要掌握的技术点**:
- Etherscan API (合约源码、ABI、交易历史)
- ERC-20 标准接口 + 常见 Rug Pull 合约模式（隐藏 mint、黑名单、暂停转账）
- SQLAlchemy 2.0 异步 CRUD
- OpenAI API / Prompt Engineering

---

### 共同负责

| 模块 | 任务 | 说明 |
|------|------|------|
| `.env` + `config.py` | 统一环境配置 | 两人共享同一份 `.env.example`，确保参数命名一致 |
| `domain/models.py` | 数据模型变更 | 任何字段增删都需要同步通知对方，因为模型是两人代码的接口契约 |
| 集成测试 | 端到端验证 | 开发者 A 的仿真输出 → 开发者 B 的分析引擎 → 最终报告，联调时一起测 |
| `app.py` | UI 功能需求 | 需要什么 UI 功能告诉 AI 生成，两人 review 即可 |

---

### 7 天 Sprint 排期建议

```
Day 1-2 ──────────────────────────────────
  A: 接入真实 RPC，验证 MonitorService 能捕获事件
  B: 完善数据模型，实现数据库 Repository CRUD
  共同: 确定 .env 配置、约定 models.py 字段

Day 3-4 ──────────────────────────────────
  A: 完善 SimulationService（approve + 税率计算 + 真实蜜罐测试）
  B: 完善规则引擎（ownership 检查 + 隐藏 mint 检测）
  B: 封装 Etherscan API 服务

Day 5 ────────────────────────────────────
  联调: A 的仿真结果 → B 的分析引擎，端到端跑通
  AI: 生成 Streamlit UI

Day 6 ────────────────────────────────────
  A: 性能优化（并发仿真、WebSocket）
  B: LLM 集成（合约源码分析）
  共同: 修 Bug、补数据

Day 7 ────────────────────────────────────
  共同: 最终联调、Demo 准备、文档收尾
```